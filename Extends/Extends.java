package Extends;

class A {
    public A(int a ) {
        System.out.print(1);
    }
   public A(String a) {
    System.out.print(a);
   }
}

class B extends A {
    // 생성자는 반환타입을 명시하지 않음;
    public B(String a) {
        super(a);
        System.out.println("B");
    }
}

class C extends B {
    public C(String a ) {
        super(a);
        System.out.print("C");
    }
}


public class Extends {
    public static void main(String[] args) {
        C c = new C("홍태선");
    }
}


/*
 * 위와 같은 상황일 경우 
 * 서브클래스를 생성할때 서브클래스의 생성자로 이동하고 만약 상속받는 클래스가 있다면 
 * 상속받는 클래스로 넘어간다음 만약 또 상속받는 클래스가 있다면 계속 올라가서 더 이상 상속받는 클래스가 없을때 까지 부모의 생성자를 호출한다.
 * 그리고 더 이상 상속받는 생성자가 존재하지 않는다면 다시 차례로 내려오면서 서브클래스들을 초기화한다.
 * 이때 서브클래스에서 상속클래스를 선택할때 명시적인 생성자가 없다면 자바 컴파일러에 의해서 슈퍼클래스의 기본 생성자가 호출된다.
 * 따라서 만약 슈퍼클래스의 파라미터가 다른 생성자가 존재하더라도 항상 기본생성자를 선택한다 하지만 여기서 조건이 있어야 하는게 명시적으로 생성자를 호출한다고 명시하지 않았을 때이다.
 * 
 * 
 */


//  그럼 위 처럼 this()를 통해서 같은 클래스내의 다른 생성자를 호출할때는 this()생성자가 우선순위가 된다.
// 그렇기 때문에 this() 생성자가 우선 초기화 되고 그 다음 기본 생성자가 호출이된다.


// 그럼 반대로 슈퍼클래스의 파라미터가 다른 생성자가 있는게 아닌
// 서브클래스에서 슈퍼클래스를 선택할때 서브클래스에서 파라미터가 다른 생성자가 존재한다고 가정했을때
// 슈퍼클래스를 호출하는 생성자 또한 기본 생성자를 호출하게 된다.


// 자바컴파일러는 클래스의 아무런 생성자도 정의되어 있지 않았을때 자동으로 기본 생성자를 생성해준다.

// 그렇다면 서브클래스에서 슈퍼클래스의 생성자를 명시적으로 호출하는 방법은 무엇일까
// super() 키워드를 사용한다. <- 슈퍼클래스의 명시적 생성자 호출이다.
// 그러면 기본생성자 호출이 아닌 super()의 파라미터의 맞는 생성자가 호출되는데 한번 실험해보자.

// 단 super() 키워드를 사용할때 항상 생성자의 맨 첫줄에 와야한다 이 특성은 this()함수와 마찬가지다.
